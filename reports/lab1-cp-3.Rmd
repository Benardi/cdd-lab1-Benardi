---
title: "EDA LAB 1 - Checkpoint 3"
author: "José Benardi de Souza Nunes"
output:
  html_notebook:
    toc: yes
    toc_float: yes
  html_document:
    df_print: paged
    toc: yes
    toc_float: yes
---

## Introdução

### Conjunto de dados utilizado

> Análise exploratória de dados do [IMDB](https://www.imdb.com/)  sobre seriados de TV e Streaming. Os dados originais e as variáveis vem [deste repositorio](https://github.com/nazareno/imdb-series) . Lá tem a explicação de como os dados foram gerados e do significado de cada variável.

```{r setup, echo=FALSE, warning=FALSE, message=FALSE}
library(tidyverse)
library(here)
theme_set(theme_bw())
```

```{r}
episodes <- read_csv(here("data/series_from_imdb.csv"), 
                    progress = FALSE,
                    col_types = cols(.default = col_double(), 
                                     series_name = col_character(), 
                                     episode = col_character(), 
                                     url = col_character(),
                                     season = col_character())) 
episodes %>% 
    glimpse()
```

### Pequena explicação sobre estimadores empregados

```
- Média: é a soma dos valores dos elementos de um conjunto dividido pelo número de elementos nesse conjunto.
- Moda: é o valor mais frequente dentro de um conjunto de valores.
- Mediana: é o valor que dentro de um conjunto de valores ordenados numericamente os divide em 50% maiores e 50% menores.
- IQR: em um conjunto de valores ordenados numericamente contém os 50% centrais dos valores, e.g. se tivessemos uma sequência de 1 até 100 o IQR iria de 25 até 75 (os 50 valores do meio).

```

```{r}
x<-rnorm(100000,mean=10, sd=2);
qqnorm(x, pch = 1, frame = FALSE);
qqline(x, col = "red", lwd = 2);
```

O gráfico Q-Q Plot (gráfico de quantis) será usado pra descrever dados que serão usados na análise. O Q-Q Plot de uma distribuição bem comportada (normal, simétrica..) é bem alinhado como no gráfico exemplo.

***

## Data Overview

### Tamanho das temporadas

```{r}
sumario_n_seasons <- episodes %>%
    group_by(series_name, season) %>%
    summarise(season_size = n()) 

episodes <- left_join(episodes, sumario_n_seasons, by= c("series_name","season")) 

episodes %>% 
    select(series_name, season, season_size) %>% 
    unique() %>%
    sample_n(10)
```

```{r}
episodes %>%
    select(series_name,
           season,
           season_size) %>% 
    unique() %>%
    ggplot(aes(season_size,..density..)) + 
    geom_density(aes(y= 2.5 *..density..),
             color="lightpink") +
    geom_histogram(binwidth = 1, 
                   fill="grey",
                   color="black") +
    scale_x_continuous(breaks=seq(0,120,5)) +
    labs(y = "Densidade de frequência", x = "Tamanho da temporada")

```

O tamanho de temporada mais frequente é em torno de 10 e em torno de 20 episódios (Duas modas ou bimodal). Algumas poucas temporadas são curiosamente longas, não existem valores que fujam ao domínio da grandeza (e.g. valores negativos) e que por isso invalidem nossa análise.    

```{r}
episodes %>%
    select(series_name,
           season,
           season_size) %>% 
    unique() %>% 
    top_n(10, season_size) %>% 
    arrange(desc(season_size))
```

Observermos as temporadas que chamaram nossa atenção por serem demasiadamente longas.

A série *Yu Yu Hakusho* que possui 4 temporadas está tendos todos seus episódios erroneamente marcados como da primeira temporada. Por esse motivo não incluiremos a série *Yu Yu Hakusho* na análise referente a tamanho das temporadas.

```{r}
episodes %>% 
    filter(series_name != "Yu Yu Hakusho") %>%
    ggplot(aes(sample=season_size)) +
    stat_qq() 
```

No Q-Q plot além disso existe uma quebra (descontinuidade) nele. Isso casa com o histograma, pois temos duas modas (valores mais frequentes).  

### Número de votos de um dado episódio

```{r}
episodes %>%
    group_by(episode) %>%
    filter(user_votes != max(user_votes)) %>%
    ggplot(aes(user_votes,y=..density..)) +
    geom_histogram(binwidth = 50,
                   fill="grey",
                   color="black") +
    scale_x_continuous(breaks=seq(0,9750,250)) +
    labs(x = "Votos dos usuários",
         y = "Densidade de frequência") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

Nitidamente temos uma moda entre 0 e 250 votos, os maiores valores são muito distantes do valor mais frequente, sendo assim a mediana e a média serão maiores que o valor mais frequente. Não existem valores que fujam ao domínio da grandeza (e.g. valores negativos) e que por isso invalidem nossa análise.    

```{r}
episodes %>%
    select(series_name,episode,season,season_ep,user_votes) %>%
    top_n(10, user_votes) %>% 
    arrange(desc(user_votes))
```

Demos uma olhada nos 10 episódios mais votados entre todos.

```{r}
episodes %>% 
    group_by(episode) %>%
    ggplot(aes(sample=user_votes)) + 
        stat_qq()
```

O gráfico de quantis representa claramente o salto nos valores máximos, os quais estão bem distantes do resto da distribuição de valores.

### Avaliação dos usuários

```{r}
episodes %>% 
    group_by(episode) %>%
    ggplot(aes(user_rating, ..density..)) +
    geom_histogram(binwidth = 0.1,
                   fill="grey",
                   color="black") +
    labs(x = "Nota do episódio",
         y = "Densidade de frequência") +
        scale_x_continuous(breaks=seq(0,10,1)) 
```

A nota mais frequente é nitidamente em torno de 8. A distribuição é *relativamente* bem comportada (simétrica) porém existe a ocorrência de notas mais baixas (entre 3 e 6). Não existem valores que fujam ao domínio da grandeza (e.g. valores negativos) e que por isso invalidem nossa análise.     

```{r}
episodes %>% 
    group_by(episode) %>%
    ggplot(aes(sample=user_rating)) + 
        stat_qq() 
```

As notas baixas discutidas anteriormente afetam a curvatura da curva e atestam que as notas do episódio não formam de fato uma distribuição simétrica (bem comportada).

### Tamanho mediano da temporada de uma série

Para representar o tamanho geral da temporada de uma série, faremos uso da mediana. Entre os argumentos para obtar pela mediana ao invés de outras medidas como uma média ou média aparada listamos:

* A mediana torna menos recorrente o aparecimento de valores não inteiros (e.g. 4,6) que não fariam sentido para algo como o tamanho de uma série.
* A mediana é uma medida robusta, ou seja ela é menos facilmente afetada por valores extremos.

```{r}
summary_season_size <- episodes %>%
    group_by(series_name) %>%
    summarize(median_season_size = median(season_size)) %>%
    ungroup()

episodes <- left_join(episodes, summary_season_size,
                      by = c("series_name")) 

episodes %>% 
    filter(series_name != "Yu Yu Hakusho") %>%
    select(series_name,
           season_ep,
           median_season_size) %>%
    sample_n(10)
```

```{r}
episodes %>%
    filter(series_name != "Yu Yu Hakusho") %>%
    select(series_name, median_season_size) %>% 
    unique() %>%
    ggplot(aes(median_season_size,..density..)) +
    geom_density(aes(y= 2.5 *..density..),
                 color="red") +
    geom_histogram(binwidth = 1,
                   fill="grey",
                   color="black") +
    scale_x_continuous(breaks=seq(0,120,5)) +
        labs(x = "Tamanho mediano de temporada",
         y = "Densidade de frequência")

```

O tamanho mediano da temporada se comporta semelhantemente ao tamanho de uma temporada.

```{r}
episodes %>%
    filter(series_name != "Yu Yu Hakusho") %>%
    select(series_name, median_season_size) %>% 
    unique() %>%
    ggplot(aes(sample=median_season_size)) + 
        stat_qq() 
```

O tamanho mediano da temporada mais uma vez se comporta semelhantemente ao tamanho de uma temporada, com o detalhe que valores extremos são menos expressivos.

### Consenso em relação à nota de um episódio

Geramos a informação de consenso como o máximo entre as frequências relativas das possíveis notas  de 1 até 10 (r1 até r10), quanto maior este máximo maior a proporção de pessoas cujas notas coincidiram. 

```{r}
episodes <- episodes %>%
    group_by(series_name,episode) %>%
    mutate(consensus = max(r1,r2,r3,r4,r5,r6,r7,r8,r9,r10)) %>%
    ungroup()

episodes %>% 
    select(episode,consensus) %>%
    sample_n(10)
```

```{r}
episodes %>%
    select(series_name, consensus) %>% 
    unique() %>%
    ggplot(aes(consensus,..density..)) +
    geom_histogram(binwidth = 0.01,
                   fill="grey",
                   color="black") +
    scale_x_continuous(breaks=seq(0,1,0.125)) +
    labs(x = "Grau de consenso",
         y = "Densidade de frequência")

```

A moda do grau de consenso está em torno de 0.3125, ou seja 31,25% das pessoas deram a mesma nota ao episódio. Além disso, valores mais altos indo até em torno de 87,50% de consenso ocorrem. Não existem valores que fujam ao domínio da grandeza (e.g. valores negativos) e que por isso invalidem nossa análise.     

```{r}
episodes %>%
    select(series_name, consensus) %>% 
    unique() %>%
    ggplot(aes(sample=consensus)) + 
        stat_qq() 
```

Os valores altos e distantes da moda afetam a curvatura do gráfico de quantis, o qual atesta que a distribuição do grau de consenso não é bem comportada (simétrica).

***

## Temporadas mais curtas são mais bem avaliadas?

```{r}
episodes %>%
    filter(series_name != "Yu Yu Hakusho") %>%
    ggplot(aes(user_rating,
               season_size)) +
    geom_point(alpha=0.08,
               color="#ff6666") +
        scale_x_continuous(breaks=seq(0,10,1)) +
          labs(x = "Nota dada pelo usuário",
         y = "Tamanho da temporada")
```

```{r}
episodes %>%
    filter(series_name != "Yu Yu Hakusho") %>%
    ggplot(aes(season_size, 
               user_rating, 
               group=season_size)) +
    geom_boxplot(position = "dodge",
                 outlier.shape = NA,
                 coef = 0,
                 color="#ff6666") +
    scale_x_continuous(breaks=seq(0,90,5)) +
    labs(y = "Nota dada pelo usuário",
         x = "Tamanho da temporada")
```

```{r}
summary <-  episodes %>%
    filter(series_name != "Yu Yu Hakusho") %>%
    group_by(season_size) %>%
    summarise(mean_usr_rating = mean(user_rating))

summary %>%
    ggplot(aes(season_size, 
       mean_usr_rating,color=season_size)) + 
    geom_point() +
    scale_x_continuous(breaks=seq(0,90,5)) +
        labs(y = "Nota Mediana",
             x = "Tamanho da temporada")
```

### Séries cujas temporadas são mais curtas são mais bem avaliadas?

```{r}
episodes %>%
    filter(series_name != "Yu Yu Hakusho") %>%
    group_by(series_name) %>%
    unique() %>%
    ggplot(aes(user_rating,
               median_season_size)) +
    geom_point(alpha = 0.1, color="#A58AFF") +
        labs(x = "Nota dada pelo usuário",
         y = "Tamanho mediano da temporada")

```

```{r}
episodes %>%
    filter(series_name != "Yu Yu Hakusho") %>%
    group_by(series_name) %>%
    unique() %>%
    ggplot(aes(median_season_size,
           user_rating,
           group=median_season_size)) +
    geom_boxplot(position = "dodge",
                 outlier.shape = NA,
                 coef = 0,
                 fill="#A58AFF",
                 width=0.5) +
    scale_x_continuous(breaks=seq(0,90,5)) +
        labs(y = "Nota dada pelo usuário",
         x = "Tamanho mediano da temporada")
```

### O tamanho da temporada afeta o consenso?

```{r}
episodes %>%
    filter(series_name != "Yu Yu Hakusho") %>%
    ggplot(aes(season_size,consensus)) +
    geom_point(alpha=0.3) +
    labs(y = "Grau de consenso",
         x = "Tamanho da temporada")
```

***

## Os episódios que recebem mais votação são episódios mais bem avaliados?

```{r}
episodes %>% 
    ggplot(aes(user_votes,user_rating,
               size = user_votes)) +
    geom_point(alpha=.3,
               position = position_jitterdodge()) +
    scale_y_continuous(breaks=seq(0,10,1)) +
    scale_x_continuous(breaks=seq(0,1000000,15000)) +
    labs(y = "Nota dada pelo usuário",
         x = "Número de votos")

```

```{r}
episodes %>% 
    group_by(episode) %>%
    ggplot(aes(user_rating)) +
        geom_density(aes(y= 0.1 * ..density..),
                 color="darkblue") +
    geom_vline(xintercept = mean(episodes$user_rating), color = "darkred") + 
    geom_vline(xintercept = median(episodes$user_rating), color = "darkgreen") +
    scale_x_continuous(breaks=seq(0,10,0.5)) +
    labs(y = "Densidade de frequência",
         x = "Nota dada pelo usuário")
```

```{r}
episodes <- 
    episodes %>% 
    mutate(bem_avaliado = user_rating >= 8)

episodes %>% 
    select(episode,user_rating,bem_avaliado)
```

```{r}
episodes %>% 
    ggplot(aes(user_votes,bem_avaliado,
               color = bem_avaliado)) +
    geom_jitter(alpha = .8, width = 0.6) +
    scale_x_continuous(breaks=seq(0,1000000,15000)) +
            labs(x = "Número de votos")
```

### Os episódios mais bem avaliados geram mais consenso?

```{r}
episodes %>% 
    ggplot(aes(consensus,bem_avaliado,
               color = bem_avaliado)) +
    geom_jitter(alpha=0.08) +
    labs(x = "Grau de consenso")

```
